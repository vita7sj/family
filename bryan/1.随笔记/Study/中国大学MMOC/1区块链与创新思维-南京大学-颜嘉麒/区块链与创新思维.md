# 初识区块链
- [初识区块链](#初识区块链)
  - [1.什么是区块链](#1什么是区块链)
    - [1.1.区块链的特点](#11区块链的特点)
    - [1.2.区块链起源与现状](#12区块链起源与现状)
      - [1.2.1.早期技术](#121早期技术)
      - [1.2.2.区块链的现状](#122区块链的现状)
      - [1.2.3.区块链未来发展](#123区块链未来发展)
    - [1.3.信任建立与形象解释](#13信任建立与形象解释)
      - [1.3.1.信任的建立](#131信任的建立)
      - [1.3.2.区块链的定义](#132区块链的定义)
      - [1.3.3.区块链的分类](#133区块链的分类)
    - [1.4.从信息互联网到价值物联网](#14从信息互联网到价值物联网)
      - [1.4.1.信息互联网](#141信息互联网)
      - [1.4.2.价值物联网](#142价值物联网)
    - [1.5.区块链的神话与误解](#15区块链的神话与误解)
      - [1.5.1.区块链不是取代互联网](#151区块链不是取代互联网)
      - [1.5.2.区块链不是万能的](#152区块链不是万能的)
    - [1.6.比特币与区块链](#16比特币与区块链)
      - [1.6.1.比特币与区块链的关系](#161比特币与区块链的关系)
      - [附录：《一种点对点的电子现金支付系统》白皮书](#附录一种点对点的电子现金支付系统白皮书)
  - [2.比特币分布式账本初探](#2比特币分布式账本初探)
    - [2.1.货币的发展阶段](#21货币的发展阶段)
    - [2.2.钱包、私钥、签名与交易](#22钱包私钥签名与交易)
      - [2.2.1.比特币的地址、私钥](#221比特币的地址私钥)
      - [2.2.2.比特币的钱包](#222比特币的钱包)
      - [2.2.3.比特币的交易](#223比特币的交易)
    - [2.3.非对称加密如何避免记假账](#23非对称加密如何避免记假账)
    - [2.4.Hash算法](#24hash算法)
      - [2.4.1.哈希运算特征](#241哈希运算特征)
      - [2.4.2.哈希运算在区块链中的作用](#242哈希运算在区块链中的作用)
      - [2.4.3.Merkle树的作用](#243merkle树的作用)
    - [2.5.双花问题和UTXO](#25双花问题和utxo)
      - [2.5.1.UTXO](#251utxo)
      - [2.5.2.比特币的分布式区块链账本](#252比特币的分布式区块链账本)
      - [2.5.3.比特币交易规则（推荐）](#253比特币交易规则推荐)
    - [2.6.共识算法和工作量证明机制](#26共识算法和工作量证明机制)
      - [2.6.1.工作量证明](#261工作量证明)
    - [2.7.区块高度、51%攻击、矿池与算力](#27区块高度51攻击矿池与算力)
      - [2.7.1.区块和区块头](#271区块和区块头)
      - [2.7.2.区块标识符、区块高度](#272区块标识符区块高度)
      - [2.7.3.矿池与算力](#273矿池与算力)
      - [2.7.4.51%攻击](#27451攻击)
    - [2.8.小结（推荐）](#28小结推荐)
      - [2.8.1.基础概念](#281基础概念)
      - [2.8.2.技术概念](#282技术概念)
  - [3.从分布式信息系统分析比特币](#3从分布式信息系统分析比特币)
    - [3.1.分布式系统概述](#31分布式系统概述)
      - [3.1.1.区块链中的分布式](#311区块链中的分布式)
    - [3.2.共识协议Paxos](#32共识协议paxos)
      - [3.2.1.proposer、acceptor、learner](#321proposeracceptorlearner)
      - [3.2.2.Paxos协议流程约束条件](#322paxos协议流程约束条件)
      - [3.2.3.Proposer与Acceptor之间的交互](#323proposer与acceptor之间的交互)
      - [3.2.4.选举过程](#324选举过程)
      - [3.2.5.Paxos算法的核心思想](#325paxos算法的核心思想)
    - [3.3.拜占庭将军](#33拜占庭将军)
  - [扩展：区块链100问](#扩展区块链100问)

## 1.什么是区块链

**狭义**来讲，区块链是一种按照**时间顺序**，将数据区块以顺序相连的方式组合成的一种**链式数据结构**，并以密码学方式保证**不可篡改**和**不可伪造**的**分布式账本**。

**广义**来讲，区块链是**利用块链式数据结构来验证与存储数据**、**利用共识算法来生成和更新数据**、**利用密码学的方式来保证数据安全**、**利用智能合约来编程和操作数据**的一种**全新的分布式基础架构与计算范式**。

### 1.1.区块链的特点

1. **去中心化**：采取了人手一本账本的`去中心化`的**分布式记账方式**。
2. **防篡改**：每一笔交易都有一个唯一标识，除了记录本次交易信息外，还含有上一笔交易的标识（形成了一个链条）
3. **公开透明**：每个人都拥有一份完整的账本，可以随时对交易信息进行查询
   - 区块链的每笔交易都是公开的，它的匿名指的是每个人的身份是无法被知道的
     - PS：**每个人都在区块链上有个和现实身份无关的虚拟身份，这个虚拟身份做的每件事情都是公开透明的**
4. **共识**：当发现有一笔交易记录错误，需要更改。那么至少需要51%的人同意才能修改，才可以重新记录在每个人的账本中（出问题就少数服从多数）

### 1.2.区块链起源与现状

#### 1.2.1.早期技术

1. **密码朋克**：做一个保护隐私的软件（使用密文保护隐私）
2. **Ecash** (匿名现金支付系统)：支付方是匿名的，收款方非匿名
3. **哈希现金**：起初是为了解决垃圾邮件的问题，其工作量证明系统解决了数字货币不被重复交易的问题（计算机在获得信息之前做一定的工作量计算，来避免重复交易）
4. **时间戳**：保证数据货币安全问题，可以保证文件先后顺序（虚拟货币被交易时，会盖上一个时间戳，最终按照区块生成时间的先后顺序相连成区块链）

#### 1.2.2.区块链的现状

中本聪对Ecash进行了优化，综合了**时间戳**、**工作量证明机制**、**非对称加密**技术、**UTXO的结构**，最终发明了比特币。而比特币底层技术就是**区块链**。

区块链从诞生到现在经历了三个阶段：

1. 区块链1.0 ==> `数字货币`，以**比特币**为代表的去中心化的数字支付。
   - eg：比特币、莱特币、山寨币
2. 区块链2.0 ==> `智能合约`，以**以太坊**为代表的支持用户自己编写智能合约，构建去中心化的应用DAPP。
3. 区块链3.0 ==> `延伸到各个领域`，将区块链用到各行业具体的场景中。
   - eg：物联网、医疗、工艺

![三个阶段](https://img2020.cnblogs.com/blog/1492185/202104/1492185-20210425221419464-952625967.png)

![金融](https://img2020.cnblogs.com/blog/1127869/202105/1127869-20210527130215329-808760947.png)

**扩展知识**：BTC、BCH、BSC的区别？（主要是三个理念不同而引发的分支）
> PS：BTC仍然是主流，其价格是BCH的30多倍，BSV的80多倍。但并不意味这BCH和BSV没有意义。他们都是比特币，代表着人们对中本聪比特币的不同理解。

1. **BTC**团队认为：**比特币**首先**是一种储值工具**即数字黄金，**最重要的是不断提高比特币的去中心化程度、安全性和匿名性，来保证价值存储的能力**。
   - 而日常的小额支付，尤其是小额支付不是最重要的，不应该在链上去执行，而是在第二层的**闪电网络**上进行小额支付
   - BTC近期工作重点除闪电网络外，还有MAST、TapRoot等一些基于密码学隐私保护方面的研究。
2. **BCH**团队认为：比特币作为一种现金，其首要功能是支付，尤其是小额日常支付，其次是要不断增加此特币的功能，不仅仅局限于支。因此在交易零确认、大区块传播、智能合约等方面不断改进，如Avalanche预共识、32MB区块、XThinner和石墨烯协议、虫洞Wormhole协议、 SLP (SimpleLedger Protoco)协议等。
3. **BSC**假中本聪团队认为：要回到1.0版本，把BTC和BCH的修改都去除掉，同时把区块大小进行无限的扩容，提出了MetaNet的概念，认为互联网将成为BSV的侧链，可以将网站代码和数据存入BSV区块链中。在这个理念的影响下，一些粉丝将大量的与交易无关的数据如文本、图像、音视频等记录到BSV区块链中，BSV也因此被戏称为网盘。

#### 1.2.3.区块链未来发展

未来发展主要呈现两大趋势：

1. 广泛被应用：许多行业和政府都能找到区块链的落地场景
   - eg：金融行业、学术领域、物联网行业
2. 加强治理：区块链现在处于关键节点，国家出台了多项的文件和政策加强区块链的治理
   - 专注技术落地，服务实体经济：国家知识产权局、工信部、卫生健康委员会、财政部、商务部等12部委、最高人民法院、地方政府相关政策

### 1.3.信任建立与形象解释

#### 1.3.1.信任的建立

传统社会信任的建立主要是四种方式：**血缘**（先天就确认了关系，后天难获得）、**道德**（可执行性差）、**霸权**（缺乏公允性）、**宗教**（太虚幻）
> 建立稳定的信任：**用权威的手段引入第三方背书**

在区块链中会采用技术手段提供第三方背书，eg：**共识**（共同制定规则）、**共治**（共同管理系统）、**共享**（共享数据等来建立可靠的信任关系）

扩展：**中心化**：中心决定节点，节点必须依赖中心，节点离开中心就没法存在。
> PS：区块链本质就是一个去中心化的分布式账本

#### 1.3.2.区块链的定义

**狭义**来讲，区块链是一种按照**时间顺序**，将数据区块以顺序相连的方式组合成的一种**链式数据结构**，并以密码学方式保证**不可篡改**和**不可伪造**的**分布式账本**。

**广义**来讲，区块链是**利用块链式数据结构来验证与存储数据**、**利用共识算法来生成和更新数据**、**利用密码学的方式来保证数据安全**、**利用智能合约来编程和操作数据**的一种**全新的分布式基础架构与计算范式**。

---

区块链本质上是一个**去中心化的分布式账本**，如果说区块链是账本，那么构成区块链的每一区块就是账本的每一页，每增加一个区块，账本的后面就会增加一页，区块链有多长，账本就有多厚。（`区块链 = 区块 + 链`）
> PS：这个账本存储在网络各个节点的手里，而不是统一存储在一个中心节点，并且是任何人都可以看得到的公开账本。（**区块链高度就相当于账本的页数，区块就相当于账本的一页，链就相当于记账本**）

#### 1.3.3.区块链的分类

根据节点的加入或者退出，是否需要批准分为（区块链开放程度）：
> PS：节点就是网络的骨干，用来验证和记录交易（通常提到的节点是区块链中的计算机，包括手机、矿机、台式机和服务器等）

1. **公有链**：公开的区块链，所有人都可以作为网络中的一个节点自由的加入或退出，节点之间基于共识机制展开工作。是真正意义上完全的去中心化。
2. **私有链**：一般用于企业内部，系统的运作规则、节点的读取和修改权限根据企业的要求进行设定。
3. **联盟链**：一种**多中心化**或者**部分去中心化**的区块链，共识机制受某些指定节点控制，一般是由若干机构联合发起。
   - eg：行业内部，它介于公有链和私有链之间，兼具部分去中心化的特性。

### 1.4.从信息互联网到价值物联网

#### 1.4.1.信息互联网

**信息互联网**：实现了全球网络信息传递（实现了信息的记录、传递，提高了信息流通的速度，降低了信息流通的成本）
> PS：以前的信息传递不仅受到**地域物理限制**，还会受到**中心控制的制度限制**以及**成本限制**，而第一代互联网（信息互联网）就是解决这些问题的 ==> 它依靠**硬件**以及更重要的**TCP/IP**这样的**基础协议**，保证**信息全球传递通道**的实现

信息互联网存在的问题：**数字壁垒、信任缺失**等问题
> PS：信息互联网的基本特征：有价值，但是没有使用价值

1. **身份无法自证**：无法跟信息互联网的对方证明，现在是你在和对方聊天
   - PS：和你聊天的人可能是一只狗
2. **信息的真实性无法保证**：每个人都可以上传信息，而这些信息都具有可复制性。而且复制成本很低，于是使得造假成本几乎为零，而没法证明造假人身份，又加剧了这个问题。
3. **数字壁垒**：很多行业和领域的数据被封闭在各个系统内部，对整个社会来说就是一个个的数据孤岛。

#### 1.4.2.价值物联网

价值物联网：为了**保护信息真实性**、**使数字化的价值**也可以像信息一样**在互联网上自由流通和传输**就提出了价值物联网的概念
> PS：通过**建立区块链价值传输协议**，利用**上链数据不可篡改**（数据篡改难度过大、代价过高）的特点，确保网络中数据的真实性

流通和传输其实可以看做交易行为：

eg：`信息互联网时代`：你为了买一套新房子，现在需要买一套房子。你首先要找到中介，等买家出现后签署买卖合同并支付中介费，然后还要去房管所变更房产证。然后去买新房子，还需要跑一遍流程，只不过由卖方变成了买方
> `价值物联网时代`：通过一份智能合约，你和想要买卖房子的人，可以直接进行交易，区块链技术保证交易双方身份可靠且不存在虚假情况

### 1.5.区块链的神话与误解

#### 1.5.1.区块链不是取代互联网

**区块链**虽然被称作第二代互联网（价值互联网），但是区块链不是取代互联网（不是对互联网原本功能进行完全的改变），而**是在原有基础上，保障信息的可靠性**。

#### 1.5.2.区块链不是万能的

区块链不是所有行业都适用，也不代表区块链技术毫无缺陷。

区块链技术不可能同时满足**可扩展**、**去中心**、**安全性**（类比<a href=`https://baike.baidu.com/item/CAP原则` target=`_blank`>CAP原则</a>），只能在三者之间取舍

eg：当我们选择**去中心化**和保证**安全**时 ==> 交易处理的效率将不可避免的降低（当交易的节点不断的增加，交易的过程会更加繁琐，效率更加低下）

### 1.6.比特币与区块链

**比特币是一种数字货币，是一种商品交换的媒介**。
> PS：比特币不依赖指定货币发行机构，而是依据特定算法，通过大量的计算产生（挖矿），其总数量有限（只有**2100万**个）

第三方的介入会使得交易的流程变得复杂，交易的效率变得更低（联想上面的买卖房子），而且我们不能完全信任第三方。

所以在电子支付日益普及的今天，如何在交易双方在无需第三方辅助下能够安全直接的交易成为了一个值得深思的问题 ==> 要解决这个问题就需要一个独立的电子货币体系，而比特币就在人们去中心化的期待而生。

#### 1.6.1.比特币与区块链的关系

比特币采用了加密技术、P2P网络传输、分布一致性校验等技术的组合有效的实现了点对点支付 ==> 区块链是比特币的底层技术（区块链就是`点对点传输、分布式账本、共识机制、加密算法`等技术的集成应用）
> PS：正是比特币的成功才将区块链带入人们的视野

#### 附录：《一种点对点的电子现金支付系统》白皮书

简版：

点对点的电子现金支付系统白皮书：
> 首先，在个人对个人的转账中，需要有一种能够不依附于第三方定价机构就能判断其价值的电子货币。
> 然后，我们需要有一份去中心化的数字账本，能够把交易记录及存储的交易信息分发给世界各地的计算机，当然，账本的运作方式与其他传统记账方式大致相同。

全文：<https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system>

---

## 2.比特币分布式账本初探

### 2.1.货币的发展阶段

实物货币 ==> 记账货币

**货币的本质**：货币唯一的，基本的职能就是**充当交换媒介**。
> 钱/纸币：纸币通常是由国家发行并强制使用的货币，是**货币的一种表现形式**，执行货币作为交换媒介的功能。

货币的发展阶段：**以物易物** ==> **实物货币**（有价值的一般等价物作为货币，比如贝壳、金银） ==> **纸币**（eg：古时候的银票、人民币） ==> **中心化记账货币**（支付宝、微信）
> PS：中心化记账货币（第三方支付）：用户把现金存到微信/支付宝，每次对外支付都由微信或支付宝代理记账，记录每笔交易与余额变化 ==> **移动支付的实质为记账货币**，是通过银行、第三方支付机构、央行负责记账的

### 2.2.钱包、私钥、签名与交易

#### 2.2.1.比特币的地址、私钥

**比特币的所有权是通过私钥和地址来确立的**。**地址类似**于一个**银行账号**的账号，想要给一个人转比特币，只要知道他的比特币地址就可以了。**私钥的作用主要是给交易来签名**，用来**证明这笔交易是由你发起的**，别人收到这笔交易，通过验证签名就可以确认交易中涉及的资金是合法的。

根据加密和解密密钥所使用的密码策略不同，可以将密码体制分为：

1. 对称密码体制：一个密码体制中的加密密钥和解密密钥相同，或者由其中一个密钥很容易推算另一个密钥。
2. **非对称密码体制**：**加密密钥不能推出解密密钥**，因此可以将加密密钥公开，这种加密密钥也被称作**公钥密码**。
   - 自从公钥加密被发明之后，一些不可逆的数学函数被提出（只能向一个方向计算，不能反向倒推）比特币使用的**椭圆曲线算法**就是其中的一种

总结：在比特币中**公钥用于接收比特币**，**私钥用于生成**其对应地址上**支付**比特币所必须要**的签名**，**用来确认这些比特币的所有权**。
> PS：具体到**比特币地址的生成**，其实是**先产生私钥**，**私钥通过椭圆曲线算法**这种不可逆的函数来**生成公钥**，然后**公钥再经过一系列不可逆的运算生成地址**。(地址是公钥的hash)

---

扩展：私钥的本质其实是一个随机选出来的数字，eg：扔硬币256次，每次记录0/1，就可以得到一个256位的二进制私钥数字（相当于生成`2^256`的随机数）
> PS：平时的随机数是伪随机，程序设计可以参考这个思路，每次在列表中随机一位数，生成一个十多位的私钥随机数

#### 2.2.2.比特币的钱包

私钥的持有者才是比特币的拥有者，那么私钥存放在哪里呢？

**钱包是私钥的容器，是密钥的管理工具**，它只包含密钥而不是确切的某一代币。一个比特币钱包内包含一系列的密钥对，每个密钥对包括一个私钥和公钥。
> PS：钱包的地址就相当于银行账户，想要往钱包里面充币提供钱包地址就行。私钥相当于银行卡密码 ==> 钱包地址（公钥）是公开的，私钥是隐秘的

扩展：比特币钱包有很多种，有PC端的、手机端的，也有专门的硬件钱包，甚至还有用纸写上私钥的纸钱包。我们一般使用的是**软件钱包**，私钥存在一个叫`wallet.dat`的文件中。
> `Wallet.dat`文件其实是用我们自己设置的密码加过密的，登录钱包软件时，需要用户输入密码来对文件解密得到真正的私钥，这时私钥存在钱包程序的内存中，当我们发起一笔交易时，钱包软件去内存中获取这一私钥来对交易进行签名操作。

我们通常还会听说冷钱包和热钱包：

1. **冷钱包**（离线钱包）：从它生成到使用都是在非联网的状态下，这类钱包往往依靠不联网的电脑、手机以及其他硬件设备运行。
   1. 优点：因为不联网所以可以避开黑客攻击和木马病毒。
   2. 缺点：使用起来比较麻烦，如果要发送交易，需要中介来交换交易信息和签名数据，成本比较高。
2. **热钱包**：在联网状态下使用的，以在线钱包和交易平台钱包等形式出现。
   1. 优点：使用方便，成本低。
   2. 缺点：因为联网，所以外界可以通过互联网访问到你存储私钥的为准，存在被黑客攻击的可能性。

#### 2.2.3.比特币的交易

从一个比特币钱包向另一个中转账，每笔交易都有数字签名来保证安全。一个交易一旦发生，那么就是对所有人都公开的，每个交易的历史可以最终追溯到相应的比特币最初被挖出的那个点。用户用钱包中的私钥来签名交易，从而证明他们有交易的输出，也就是其中的比特币。

**比特币是以交易输出的方式存储到区块链中的**。
> PS：比特币不存在于任何地方，即使是硬盘上。持有比特币其实是拥有特定比特币的地址，但所谓的币并不是直接就存在于这个地址中的。世界上没有一个可以摸得着的实物，或者是一个数据文件，可以被叫做比特币的。**有的只是各个地址之间的转账记录**，余额时增时减。所有的交易都存放在一个非常大的账本文件中，这个文件叫做`区块链`。如果想知道一个比特币地址中的余额，我们需要到区块链中去计算。

总结：**比特币的交易本质是一个包含输入值于输出值的数据结构**。

通过一个例子来看交易中的选项：小明给小张转一些比特币，那么这个交易就有三项信息：

1. **输入**：这里记录了最初小明拥有这些币是从哪些地址转给他的（记录上1个或多个的节点信息）
2. **数目**：这里是小明准备给小张转多少比特币
3. **输出**：小张的比特币地址

除了第一笔交易是矿工挖矿所得，每一笔交易都拥有一个或多个输入，以及一个或多个输出。
> PS：第一笔矿工挖矿的收入交易通常被称为Coinbase，它没有输入，所以输入的哈希总是被标记为0000000...0000；其他的交易，任何一个交易输入都会唯一追溯到区块链上在本区块之前的某个交易哈希，以及索引。

通过交易哈希和索引，即可唯一确定一个未花费的交易输出 ==> UTXO。这样，每一个交易输入都和之前的某个交易输出关联了起来。

Q：想要知道余额不是存储在地址之中的，都需要去区块链中计算出来，那么效率是否很慢？ ==> A：直接可以根据输入和输出的差值计算出余额，不用去区块链里面重头溯源的
> PS：比特币本身并没有账户余额这个概念，我们看到的某个地址有多个比特币，其实是比特币钱包根据未花费的交易输出计算出来的

比特币的签名与验签：**签名必须使用私钥**，而只有私钥对应的**公钥**才**能验证签名通过**。（比特币中还支持多方签名）
> 其他人没法冒充小张去领钱是因为：只有小张有这个账号地址对应的私钥，其他人只能用小张提供的公钥去验签，而不能去签名领钱。

### 2.3.非对称加密如何避免记假账

**交易验证的环节**：**把公钥做哈希看这个值是否与UTXO中描述的地址一致**，**然后**再**用提供的公钥对交易中提供的签名信息进行验签**，以确定交易是UTXO的所有者发出的交易。在交易的验证环节，主要用了`非对称加密`中关于签名、验签的功能。
> PS：其中比特币中的公私钥生成以及签名算法ECDSA都是基于椭圆曲线算法的。

扩展：**椭圆曲线算法**：椭圆曲线密码学简称ECC，是一种建立公开密钥加密的算法(非对称加密)。类似的还有RSA、ElGamal算法等。**ECC被公认为在给定密钥长度下最安全的加密算法**。
> PS：椭圆曲线实际上是一个总称，是一种数学基础算法，不是真正用在密码学上的密码算法。许多非对称加密算法，例如RSA、椭圆曲线，能够被大家认可使用，是因为每种加密算法在数学上都有一个运算，而这个运算的逆过程被证明是数学难题。(`椭圆曲线的难点在于被广泛承认的解决椭圆曲线离散对数问题的困难性上`)

在比特币交易中有**三个保障来避免记假账**：

1. 用私有密钥对交易信息签名，必须用配对的公共密钥验证签名，私用密钥的使用者必须是付款人。
   - PS：`使用非对称加密算法来完成的`
2. 被签名的交易信息在网络上进行广播，所有参与到比特币网络的人都可以接到这笔交易信息，并且可以对交易信息进行验签，确保交易是合法的。
   - PS：`使用非对称加密算法来完成的`
3. 接收到交易信息后，大家会按照约定的规则生成区块，就是一个数据块，这个数据块中包括所有的交易明细信息，按照merkle树的方式组装起来。
   - PS：`merkle树的数据结构可以很好的保证数据安全`

### 2.4.Hash算法

哈希算法：把任意长度的输入通过散列算法变换成固定长度的输出。
> PS：具体来说就是哈希算法将数据打乱、混合、压缩成一个摘要，使得数据量变小，重新创建一个叫做哈希值的指纹。

#### 2.4.1.哈希运算特征

1. **单向性**：哈希算法必须具备单向性;
   - 只能由输入的数据或者消息计算出一个定长的哈希值，而不能通过这个哈希值反向推算出输入的数据或者消息。（破镜不可重圆）
2. **易用性**（固定长度）：可以根据任意长度的消息计算出固定长度的散列;
   - 哈希算法生成的哈希值的长度必须是固定的，而且是针对任意长度的输入数据。
3. **任意性**：不同的输入就有不同的输出;
   - 无论输入数据的长度大小，都会产生定长的哈希值，这样比对结果就比较快速方便。
   - 哈希算法被发明的目的之一就是根据此需求来的，也成为了哈希算法的一大特性。
   - 可以实现对数据完整性和一致性的判定，只有一模一样的数据经过同一个哈希运算得到的哈希值才是一样的。
4. **算法效率高**：计算哈希值的时间短；
   - 保证不管数据有多长，都能在可接受的范围内得到哈希结果。

PS：典型的Hash算法是MD系列和SHA系列。哈希算法运用的哈希函数是一类比较成熟的散列函数。

#### 2.4.2.哈希运算在区块链中的作用

普通的指针只是保存结构体在内存中的位置。而哈希指针是不仅要保存**结构体在内存中的位置**，还要保存**结构体的哈希值**。
> PS：好处就是不仅可以找到结构体的位置，还能知道结构体是否被篡改）

比特币背后的技术主要是区块链，而区块链是由一个个区块连接而成，区块链和普通链表的`主要区别`就在于`用哈希指针代替了普通的指针`。**普通链表如果内容发生了改变，指针不会发生改变，而区块链一旦内容发生了变化，后面区块的哈希指针都会发生变化**，类似于多米诺骨牌效应。
> PS：哈希运算能够帮助识别区块数据是否被篡改，区块链的哈希指能够唯一而精准地标识一个区块，区块链中任意节点通过简单的哈希计算都可以获得这个区块的哈希指，计算出的哈希值没有变化也就意味着区块链中的信息没有被篡改。另外，哈希运算还能够帮助把各个区块串连成区块链。每个区块都包含上一个区块的哈希值和下一个区块的值，就相当于通过上一个区块的哈希值挂钩到这一个区块，通过这一个区块的哈希值挂钩到下一个区块，就自然而然形成一个链式结构的区块链。

![哈希指针](https://img2020.cnblogs.com/blog/1127869/202105/1127869-20210526145248191-876416678.png)

哈希运算还可以加密交易地址

#### 2.4.3.Merkle树的作用

什么是Merkle树？它使用的是单向哈希。哈希树的顶部为顶部哈希，亦称根哈希或主哈希。它是通过并联两个子哈希来往树.上爬直到找到根哈希。

**Merkle树的作用**：

1. 可以快速定位每笔交易，由于交易在存储上是线性存储，定位到某笔交易会需要遍历，效率低时间慢，通过这样的二叉树可以快速定位到想要找的交易。
2. 在不需要存储整个数据的情况下，就可以简明地核实交易是否被篡改，从交易到每个二叉树的哈希值，有任何一个数字的变化都会导致根哈希的变化。同时，如果有错误，可以快速定位到错误的地方。

Merkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候`Merkle tree`也表示为`Hash tree`：

> 1. `merkle tree`是一种树状结构，它具有树结构的所有特点;
> 2. `merkle tree`的叶子节点的值是数据集合的单元数据或者是单元数据的哈希值;
> 3. 非叶子节点的值是根据它下面所有叶子节点的值，按照hash算法计算而得出的。

![Merkle树](https://img2020.cnblogs.com/blog/1127869/202105/1127869-20210526150855303-1973296868.png)

类比案例：文件上传的时候需要分片上传，那最后文件是否被篡改或者顺序是否错误？就可以参考Merkle树

eg：先在本地把文件临时分割为4份，f1、f2、f3、f4，那么最外层的叶子值就是A=hash(f1)、B=hash(f2)、C=hash(f3)、D=hash(f4)，上一层就是X=hash(A+B)、Y=hash(C+D)，根就是root=hash(X+Y)，上传文件的时候把root的hash值带上，那么最后验证下root的hash就知道有文件有没有被篡改了
> 如果想快速定位错误文件也很方便，先看root对不对，不对就看X和Y哪个不对，然后逐步往下看。

挖矿：区块头中有个参数叫随机数Nonce，寻找这个随机数的过程就叫做挖矿
> 网络上任何一台机器只要找到合适的数字填到自己的Nonce位置，使得区块头这6个字段(80个字节)的数据的哈希值符合目标哈希指。

![区块](https://img2020.cnblogs.com/blog/1127869/202105/1127869-20210526152205815-1260806551.png)

### 2.5.双花问题和UTXO

双花问题：一笔钱被花费了两次甚至多次。eg：**数字货币中的双花问题**
> 在数字货币系统中，数字资产本质上是以互联网为基础的虚拟数字，简单来说所谓的数字资产其实就是一串字符，因此它很容易被复制或者多次发送使用，在这种情况下，如果没有中心机构的存在，人们并不能确定一笔资产是否已经被花掉，这就导致系统可能存在同一笔数字资产因不当操作被重复使用的情况。

为了解决双花问题，我们日常的数字资产使用依赖于第三方信任机构进行。这类机构对数据进行中心化管理，由它保管交易总帐，并通过实时修改账户余额的方法来防止双重支付的出现。（第三方机构的最大弊端是验证费用极高）

#### 2.5.1.UTXO

**在比特币系统中是如何避免双花问题的**？矿工在生成区块的时候，会从网络上收集交易信息，交易信息中包含了付款人的私钥签名。矿工首先会验证签名是不是正确的，只有正确的签名才会被认为是付款人认可的支付。然后矿工会从以前的区块链中追溯，看看付款人这次消费的比特币是不是以前没有被消费过。然后记录下付款人可用的比特币余额。这个过程也被称为UTXO机制。

UTXO是`Unspent Transaction Outputs`的缩写，全称叫做**尚未使用的交易输出**：

- U代表Unspent，表示未支付的或尚未使用的，`尚未支付` 指的是这个交易输出还没有出现在其它交易的输入端。
- TX是transaction的缩写，交易是从一个比特币钱包向另一个钱包转账，是唯一可以改变比特币所有权的方式，包含了输入、数目和输出这些基本内容。
- O是Output，是输出的意思，TXO连起来就是指**交易输出**。

比特币里并没有用户帐户的概念：比特币是以交易输出，也就是TXO的形式存在的。我们说自己有多少比特币实际上是指的我们拥有所有权的那些UTXO中所指明的比特币的数量。
> 可以理解为：**没有比特币，只有UTXO**。eg：小明有10个比特币，本质上是当前区块链账本中，有若干笔交易的UTXO项收款人写的是小明的地址，而这些UTXO项的数额总和是10。

#### 2.5.2.比特币的分布式区块链账本

比特币的分布式区块链账本，由一笔一笔的交易形成的，每一笔交易都要花费一笔输入产生一笔输出，而其所产生的输出，就是`未花费过的交易输出`，也就是UTXO。这些交易构成了一组链式结构，所有合法的比特币交易都可以追溯到前一个或多个交易的输出，链条的源头就是挖矿奖励，末尾则是当前未花费的交易输出。

#### 2.5.3.比特币交易规则（推荐）

1. 除了coinbase交易之外，所有的资金来源都必须来自前面某一个或者几个交易的UTXO。
2. 任何一笔交易的**交易输入总量必须`等于`交易输出总量**，等式两边必须配平。

举个UTXO案例：`A`挖矿得了12个比特币，转给`B`2个比特币，**剩余10个比特币需要转给A自己**才能符合比特币的交易规则
![order demo](https://img2020.cnblogs.com/blog/1127869/202105/1127869-20210526191057118-1241132067.png)

---

UTXO技术也并非100%保证基于区块链的交易中杜绝双花问题。
> eg：51%攻击，又被称`Majority attack`，这种攻击是通过控制网络算力实现双花。

### 2.6.共识算法和工作量证明机制

什么叫**共识**？所谓共识，从语文的角度进行理解，可以简单解释为，许多不同的人对同一件事情达成一样的或者至少说方向一致的看法。这个解释同样适用于比特币网络当中。

原则上在比特币网络中每个矿工都有权力生成新的区块，那么我们到底该选择谁的区块作为整个网络的新区块？这个新区块生成之后，在这条链上进行的交易能不能通过？
> 在区块链当中，每个节点都是平等的，没有一个中心机构的存在，这时候就需要通过共识机制来达成节点间的一致。

**共识算法**是为了达成共识所依据的一种规则，是筛选出具有代表性的节点的方法。为此，区块链设计了一定的底层算法，通过这个特定的算法来选出哪个可以生成新区块的节点，同时对于每一笔在这条区块链上进行的交易是否准许完成进行了约束和规定，也就是共识算法。
> PS：共识算法规定了下一个新区块由哪个矿工生成。在这条区块链上一笔交易要达成，需要被共识算法选出的部分节点达成一致的观点 ==> 对一笔交易，如果利益不相干的若干个节点能够达成共识，就可以认为全网对此也能够达成共识。

共识算法有很多种，主要有 **`工作量证明、权益证明、委托工作量证明、委托权益证明、实用拜占庭容错算法`** 等，他们最终的目的是一致的， 但在具体的实现过程中各具特色。

#### 2.6.1.工作量证明

工作量证明，英文全称叫`proof of work`，通常我们叫它**POW**。工作量证明就是一份证明，用来确认你做过一定量的工作。怎么证明呢？==> 通过工作结果
> PS：当用户做一定难度的工作得出一个结果时，通过展现出这个结果证明你完成了一定的工作量。

**POW作为一种共识机制**，它**是结果导向而非过程导向**的。

1. **原因**：实际应用中，如果我们通过监测工作的整个过程来证明工作量，这是极为低效的，为了保证一定的效率，就设计了通过验证结果的方式证明工作量的方法。
2. **关键特性**：`不对称性`
   - 进行实际工作的用户需要付出很多的工作量才能得到一个符合已定条件的结果，但是作为验证方却可以根据用户提供的材料很容易重算这个结果，同时验证这个结果是否满足提前规定好的条件。

举个例子：在`Hello， world!`的后面添加一个nonce的整数值，然后对变更后的字符串进行哈希运算。得到的哈希结果以`0000`开头则验证通过。
> PS：为了达到这个工作量证明的目标，我们需要不停的递增nonce值，对得到的新字符串进行哈希运算。按照这个规则，我们需要经过4251次计算才能找到恰好前4位为0的哈希散列。（有时候一次就得到`0000`开头的nonce整数，但绝大多数情况下是不得不通过对nonce的值进行逐个递增的方式来改变字符串的内容，多次尝试后最终得到满足条件的值）

**在工作量证明中，你工作的时间越长，工作时采用的设备越先进，你的工作量就越高，你收获的也会越多。**
> PS：短期看可能有运气因素，但是宏观长期来看是公平的，谁工作付出的多，谁得到的就多。这也是我们生活的写照一有付出才有收获。

把这种工作量机制运用到比特币网络中就是我们说的工作量证明机制POW：
> PS：工作量证明机制具有完全去中心化的优点，造成了大量的资源浪费，达成共识所需要的周期较长（大规模的商业对此还在考察中）

在PoW机制中，所有节点通过随机的尝试和计算，直到有一个节点找到了那个随机哈希散列的数值解，成为有资格生成新区块的主体。
> PS：首先，生成要加入到区块链中的一笔新的交易信息，然后在基于工作量证明机制构建的区块链网络中，所有节点开始不断尝试和计算，直到第一个节点找到了那个随机哈希散列的数值解，于是它就得到了生成新区块的权力。

### 2.7.区块高度、51%攻击、矿池与算力

#### 2.7.1.区块和区块头

区块是一种被包含在公开账簿里的**聚合了交易信息的容器数据结构**，这个公开账簿就是区块链。**区块是构成区块链的基本单元，由包含元数据的区块头和包含交易数据的区块主体构成。**

一般来说在整个区块链系统中，大约每十几分钟就会创建一个区块。这个区块里面包含了这段时间内全网范围发生的所有交易信息，也就
是区块主体部分。那么这个**区块生成之后要怎么跟原先的区块链接起来呢**?

区块头中包含了三组元数据，其中第一组就是上一个区块的哈希值。也就是说，第二个区块的父哈希为第一个区块的哈希，第三个区块的父哈希为第二个区块的哈希，通过这种方式，就把一个个区块链接起来了，形成了一个前向的链表。

区块链 ==> 由一个一个区块以链式结构组成的。（元数据：难度、时间戳和nonce、merkle树根）

#### 2.7.2.区块标识符、区块高度

**每个区块都有唯一的区块哈希值**表示它的身份，就像我们的身份证号码一样，知道一个区块的哈希，就一定能找到唯一匹配的那个区块，这就是区块标识符。

还有一种识别区块的方式是通过该区块在区块链中的位置，即**区块高度**。
> PS：区块高度是用来标识一个区块在区块链中位置的一个概念。

注意：和区块hash不一样，**区块高度不能唯一标识一个区块**。原因：在同一时间，有可能存在两个或两个以上的区块，他们相对于整条区块链来说，处于平等的位置，所以他们有着相同的区块高度。
> eg：**一栋楼中有201也有203，201和203就是区块hash（一栋楼里面房间号是唯一的）二楼就类似于区块高度**

#### 2.7.3.矿池与算力

算力也叫**哈希率**，是用来衡量进行哈希运算的能力的指标，或者说进行一次哈希计算所需要使用的时间。
> PS：如果说网络达到了10T哈希每秒的哈希率时，就意味着它可以每秒进行10万亿次哈希运算

在PoW机制中，所有节点通过随机的尝试和计算，直到有一个节点找到了那个随机哈希散列的数值解，成为有资格生成新区块的主体。
> PS：这个不断尝试就叫做**哈希碰撞**（解出随机哈希值不断尝试的过程。一个挖矿机每秒钟能做这种碰撞的次数，代表其算力。矿工进行挖矿所使用的机器越先进，算力就会越高）

整个区块链网络之所以能运行，靠的就是整个网络的`矿工`，因为他们通过算力解答加密难题，从而挖出新的区块。挖出区块后他们就有权力将转账信息放入到区块中，然后完成这笔转账，这就是区块链转账的基本原理。

中本聪一开始就定义了比特币总量为2100万个，并且加密数学题的难度也越来越大。正所谓众人拾柴火焰高，越来越多的人把自己的矿机拿出来，组成了**挖矿小分队**，这类组织就被称为**矿池**。

#### 2.7.4.51%攻击

51%攻击出现的根本原因:在整个网络中，**有人的算力超过了全网的50%**，那么在他的控制算力的这段时间，可以将区块逆转，进行反向交易，实现双花。
> PS：尽管51%的攻击不会产生新币或直接导致区块链崩溃，但对参与者对加密货币的信心会产生严重影响。

举个例子：Alice凭借51%以上的算力控制，实现了同一笔比特币的**双花**。

![1](https://img2020.cnblogs.com/blog/1127869/202105/1127869-20210526202412175-387482557.png)

1. ALICE在控制全网51%的算力的期间，她把一部分的比特币发给在交易所的钱包中，这条分支我们命名为分支A。
2. 同时她又把这些比特币的发给自己的另一个比特币钱包，这条分支我们命名为分支B。
3. 分支A上的比特币确认后她立刻卖掉这些比特币（套现）这时候分支A成为主链。
4. 然后她在分支B上进行挖矿，因为他获得了51%的算力，所以她有很大几率获得记账权，于是很快分支B的长度超过了分支A的长度，那么分支B就会成为主链。
5. 这时分支A上的交易就会被回滚，由于交易回滚，分支恢复到她进行第一笔交易之前的状态（回滚到分叉点）她之前换成现金的那些比特币又回到她手里了，这些比特币就成为交易所的损失了。
6. 最后，Alice把这些比特币发到自己另一个钱包。

![2](https://img2020.cnblogs.com/blog/1127869/202105/1127869-20210526202454903-1742168521.png)

虽然看起来51%攻击非常恐怖，不过这通常仅存在于理论情况下。因为如果你想做到，首先需要足够的钱去掌控全网51%的算力，这将是非常大的一笔投资。其次在攻击后，币种价格会受到影响，你要卖出非常多的币才能达到收支平衡。这就是**51%攻击悖论**。

### 2.8.小结（推荐）

#### 2.8.1.基础概念

1.**矿工**：**矿工就是指参与比特币挖矿的个体**，也就是说，每一个致力于生产新区块的比特币节点的主人，就是一个矿工，是一切行为的操作者，也就是比特币网络参与的主体。

2.**矿池**：矿池的概念是在矿工的基础上延伸出来的。随着参与挖矿的矿工越来越多，一个个体矿工要想挖到矿，得到生成新区块的权力的可能性越来越低，所以一些矿工集合起来，集合各自的算力，提高挖到矿的可能性。这种**矿工的集合体就是矿池**。

★3.公钥、私钥：公钥和私钥是一组配合使用的概念，他们之间有着紧密的联系。简单来说，**私钥是系统随机生成的，公钥是由私钥计算得出的**;**公钥负责加密，私钥负责解密**;**私钥负责签名，公钥负责验证**。在两者的配合使用之下，矿工才能完成比特币的交易。

4.**钱包**：比特币钱包，就是用来装密钥的容器，它只包含密钥而不包括具体的多少个比特币。具体来说，**钱包里面存放了一系列的密钥**，每一密钥对应着一个私钥和由这个私钥生成的公钥，`用于完成这个钱包主人可能要进行的比特币交易`。**钱包还有一个地址**，`这个地址就相当于你支付宝的账号一样，你要提供自己的账号，才能向外转账或者给自己充值`。

5.**交易**：而这里提到的交易，就是**利用矿工掌握的私钥，把比特币从一个地址转到另一个地址的行为**。我们所说的比特币，其实就是一系列交易输出的集合，我们说自己有多少比特币实际上是指的我们拥有所有权的那些UTXO中所指明的比特币的数量。

6.**区块**：**区块是构成区块链的基本单元**。在区块链中，每隔一段时间就会形成一个新的区块，矿工们就是在通过挖矿争夺生成新区块的权力。**每一个区块由区块头和区块主体构成**。在`区块头中包含了前一个区块的哈希信息`，可以帮助新区块和之前的区块联系起来;而`区块主体则包含了这一段时间内所有的交易信息`。

7.**算力**：是**用来衡量进行哈希运算的能力的指标**，**它可以用每秒完成哈希碰撞次数来衡量**。算力越强，挖到下一个新区块的可能性也相应的越大。

#### 2.8.2.技术概念

1.**哈希加密算法**：通过hash加密能够将一段任意长度的数据，在较短时间内转换为定长的Hash值。而且哪怕输入的数据发生了哪怕1比特（bit）的改变，输出的hash值也将产生极大的改变。通过Hash算法加密的数据具有很强的防篡改能力。

2.**共识算法**：是区块链网络中用来决定如何选出那个可以生成新区块的节点的机制。同时对每一笔在这条区块链上进行的交易是否允许完成进行的约束和规定。
> 简单来说：共识算法规定了下一个新区块由哪个矿工生成。在这条区块链上一笔交易要达成，需要被共识算法选出的部分节点达成一致的观点 ==> 对一笔交易，如果利益不相干的若干个节点能够达成共识，就可以认为全网对此也能够达成共识。

3.**POW**（Proof of Work）工作量证明机制。是要求矿工通过不断的Hash碰撞，直到一个矿工最先找到正确的Nonce值，就获得了生成新区块的资格。

4.**UTXO**：尚未使用的交易输出（Unspent Transaction Output）UTXO的使用是为了解决电子货币交易中存在的双花问题。
> 比特币分布式账本由一笔笔的交易构成，每笔交易都要花费一笔输入，产生一笔输出，而其产生的输出就是UTXO。当一笔交易被广播到区块链网络之后，接收到交易的节点会对交易进行验证，检查其是否被花费过，即是否存在UTXO中，如果交易输出已不存在未花费的交易列表中，则验证失败，通过这种方式比特币有效的杜绝了绝大部分的双花问题。

---

## 3.从分布式信息系统分析比特币

### 3.1.分布式系统概述

分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像是单个相关系统。各组件分布在网络计算机上，并且组件之间仅仅通过消息传递来通信并协调行动。

从进程的角度来看，在两个台主机的进程上，分别运行着两个程序，**这两个程度相互协调**，最终的目的是**完成一个任务**。 在理论上来讲，这两个程序所组成的系统，就可以称之为**分布式系统**。
> PS：这两个程序可以是相同的，也可以是不同的。**如果是相同的两个程序，我们将其称之为`集群`**，也就是这两个相同的程序，通过不断地**横向发展**，进而达到**提高服务能力**的目的。

分布式系统的**主要特征**：

1. 在分布式系统中，可以随意分布多台计算机之间在空间上的位置，系统中的多台计算机之间没有主、从之分，即没有控制整个系统的主机，也没有受控的从机。
2. 系统资源被所有计算机共享。每台计算机的用户不仅能够使用本机的资源，还能够使用本分布式系统中其他计算机的资源（包括CPU、文件、打印机等）
3. 系统中任意两台计算机都可以通过通信来交换信息。
4. 与集中式系统相比，分布式系统具有性价比更高、处理能力更强、可靠性更高、扩展性很好的特点。

#### 3.1.1.区块链中的分布式

1. **分布式的信息发布与传输**：每个参与系统的节点都可以发起信息，每一个参与的节点可与相邻节点进行信息交互，全网公开传递有价值的信息。
2. **分布式记账**：每个参与系统的节点只要根据共识机制，完成工作量的设定，便能取得数据库的记账权，且记录可以追溯查询，但不可篡改。
3. **分布式储存**：分布式记账后在记录信息加工中加上一个时间戳，便会产生区块数据，网络广播出去后，就会在区块链中形成，每个节点可以选择储存完整的数据或者是部分数据。每个节点都可以拥有一份完整的本地数据储存实时的更新。

PS：分布式系统易遇到很多问题，比如最经典的一致性的保障的问题。
> 如果一个分布式集群无法保证处理结果一致的话，那任何建立于其上的业务系统都无法正常工作。

### 3.2.共识协议Paxos

如何才能让一组机器就某条消息达成一致呢？==> 由Lamport发明的Paxos，是一种应对计算崩溃故障问题的共识协议
> Paxos协议由Lamport最早在1990年提出，目前已经成为应用最广的**分布式一致性算法**。==> 只要大多数的机器接受某个proposal提议，这就可以保证系统中所有的机器都不会出现不一致的状态。

#### 3.2.1.proposer、acceptor、learner

Paxos中proposer和acceptor是算法的核心角色：paxos描述的就是在一个由**多个proposer**（提案者）和**多个acceptor**（批准者）构成的系统中，如何让多个acceptor（批准者）针对proposer（提案者）提出的多种提案达成一致的过程，而**learner（学习者）只是学习最终被批准的提案**。
> PS：通俗讲 ==> 多个proposer（提案者）提交各种的value操作，learner（学习者）只执行被大多数acceptor（批准者）批准的那一个value操作。

**Proposer提案者**：Proposer可以有多个，Proposer提出value。（value在工程中可以是任何操作。不同的Proposer可以提出不同的甚至矛盾的value）
> eg：某个Proposer提议`将变量X设置为1`，另一个Proposer提议`将变量X设置为2`，但对同一轮Paxos过程，最多只有一个Value被批准。

**Acceptor批准者**：Acceptor有N个，Proposer提出的value必须获得超过半数的Acceptor批准后才能通过。另外，Acceptor 之间完全对等独立。

**Learner学习者**：Learner学习被批准的value。所谓学习就是通过读取各个Proposer对value的选择结果，如果某个value被超过半数Proposer通过，则Learner学习到了这个value。
> PS：这里类似议会机制，某个value需要超过半数的Acceptor批准，Learner需要至少读取`(N/2)+1`个Accpetor，至多读取N个Acceptor的结果后，能学习到一个通过的value。

#### 3.2.2.Paxos协议流程约束条件

Paxost的协议流程还**需要满足如下的约束条件**:
1. Acceptor必须接受它收到的第一个提案;
2. 如果一个提案的v值被大多数Acceptor接受过，那后续的所有被接受的提案中也必须包含v值。
   - v值可以理解为提案的内容，提案由一个或多个v和提案编号组成)
3. 如果某一-轮Paxos协议批准了某个value，则以后各轮Paxos只能批准这个value；每轮Paxos协议分为准备阶段和批准阶段，在这两个阶段Proposer和Acceptor有各自的处理流程。

#### 3.2.3.Proposer与Acceptor之间的交互

**Proposer与Acceptor之间的交互**主要有**4类消息通信**（Paxos两个阶段的4个过程）
![4个过程](https://img2020.cnblogs.com/blog/1492185/202105/1492185-20210530114929240-681428776.png)

1. **准备阶段**
   1. proposer向网络内超过半数的acceptor发送prepare消息
   2. acceptor正常情况下回复promise消息
2. **批准阶段**
   1. 在有足够多acceptor回复promise消息时，proposer发送accept消息
   2. 正常情况下acceptor回复accepted消息

![准备阶段](https://img2020.cnblogs.com/blog/1492185/202105/1492185-20210530114320426-500413748.png)

![批准阶段](https://img2020.cnblogs.com/blog/1492185/202105/1492185-20210530114724015-1665459173.png)

#### 3.2.4.选举过程

![选举过程](https://img2020.cnblogs.com/blog/1492185/202105/1492185-20210530115116504-1985011859.png)

1.**准备阶段**：

a) Proposer发送Prepare请求，Proposer生成全局唯一且递增的ProposaIID，向Paxos集群的所有机器发送Prepare请求，这里**不携带value，只携带ProposaIID**。

![准备阶段1](https://img2020.cnblogs.com/blog/1492185/202105/1492185-20210530115610536-601772128.png)

b) Acceptor应答Prepare，收到Prepare请求后，判断收到的ProposaIID是否比之前已响应的所有提案的ProposaIID大？如果否:不回复或者回复Error。如果是:

1. 在本地持久化ProposaIID，可记为Max_ProposaIID。
2. 回复请求，并带上已Accept的提案中ProposaIID最大的value (若此时还没有已Accept的提案，则返回value为空)
3. 做出承诺：不会Accept任何小于Max_ProposaIID的提案。

![准备阶段2](https://img2020.cnblogs.com/blog/1492185/202105/1492185-20210530120119368-260821743.png)

2.**选举阶段**：

1. proposer发送Accept经过一段时间后，Proposer收集到一些Prepare回复，有下列几种情况:
   1. 回复数量>一半的Acceptor数量，且所有的回复的value都为空，则proposer发出accept请求，并带上自己指定的value。
   2. 回复数量>一半的Acceptor数量，且有的回复value不为空，则proposer发出accept请求，并带上回复中ProposaIID最大的value(作为自己的提案内容)。
   3. 回复数量<=一半的Acceptor数量，则尝试更新生成更大的ProposaIID，重新从准备阶段重新开始（P1a开始）。
2. Acceptor应答acceptAccpetor收到Accpet请求后，判断:
   1. 收到的N >= Max_N(一般情况下是等于)，则回复提交成功，并持久化N和value。
   2. 收到的N < Max_N，则不回复或者回复提交失败。
3. Proposer统计投票经过一段时间后，Proposer收集到一些Accept回复提交成功，有几种情况:
   1. 回复数量>一半的Acceptor数量，则表示提交value成功。此时，可以发一个广播给所有Proposer、Learner， 通知它们已commit的value。
   2. 回复数量<=一半的Acceptor数量，则尝试更新生成更大的ProposaIID，重新从准备阶段重新开始（P1a开始）

![选举阶段1](https://img2020.cnblogs.com/blog/1492185/202105/1492185-20210530120642253-1367669811.png)

#### 3.2.5.Paxos算法的核心思想

1. 引入了多个Acceptor，避免单个Acceptor成为单点。Proposer用更大ProposaIID来抢占临时的访问权，避免其中一个Proposer崩溃宕机导致死锁。
2. 保证一个ProposaIID，只有一个Proposer能进行到第二阶段运行，Proposer按照ProposaIID递增的顺序依次运行。ProposaIID肯定可以获取到此值，并且认同此值。
3. 新ProposaIID的proposer采用后者认同前者的思路运行。在肯定旧ProposaIID还没有生成确定的value (Acceptor提交成功一个value)时，新ProposaIID会提交自己的value，不会冲突。一旦旧ProposaIID生成了确定的value，新ProposaIID肯定可以获取到此值，并且认同此值。

---

### 3.3.拜占庭将军

todo

## 扩展：区块链100问


<https://study.163.com/course/introduction.htm?courseId=1004954004>